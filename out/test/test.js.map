{"version":3,"file":"test.js","sourceRoot":"","sources":["../../test/test.ts"],"names":[],"mappings":";;AAAA,uCAIkB;AAClB,+CAA2C;AAC3C,iDAA6C;AAO7C,MAAM,WAAW,GAAG,sBAAW,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;AAC7D,MAAM,KAAK,GAAG,IAAI,eAAM,CAAC,WAAW,CAAC,CAAC;AACtC,MAAM,WAAW,GAAG,IAAI,4BAAiB,CAAC,KAAK,CAAC,CAAC;AACjD,MAAM,MAAM,GAAG,IAAI,iBAAO,CAAC,WAAW,CAAC,CAAC;AACxC,MAAM,IAAI,GAAG,MAAM,CAAC,eAAe,EAAE,CAAA;AAErC,MAAM,aAAa,GAAG,CAAC,GAAO,EAAE,EAAE,CAC9B,iBAAO,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;AAEpC,MAAM,OAAO,GAAG,CAAC,IAAQ,EAAE,EAAE,CACzB,aAAa,CAAC,IAAI,CAAC,KAAK,SAAS,CAAA;AAErC,MAAM,UAAU,GAAG,CAAC,IAAU,EAAE,KAAc,EAAE,EAAE;IAC9C,IAAI,CAAC,IAAI;QAAE,OAAO;IAClB,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;QACf,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,CAAA;QACxD,MAAM,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,CAAA;KACnC;;QAEG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IACzD,IAAI,IAAI,CAAC,QAAQ;QACb,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAK,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,CAAA;AAClE,CAAC,CAAA;AAOD,MAAM,OAAO,GAAG,CAAC,IAAS,EAAE,EAAE;AAE9B,CAAC,CAAA;AAyBD,IAAI,EAAU,CAAC;AAEf,IAAI,MAAM,CAAC","sourcesContent":["import {\n    ANTLRErrorListener, CharStreams, CommonToken, \n    CommonTokenStream, RecognitionException, Recognizer, \n    Token\n} from \"antlr4ts\";\nimport { CLexer } from './generated/CLexer'\nimport { CParser } from './generated/CParser'\nimport * as fs from 'fs';\nimport { instruction, OP, operand, ind, imm, REGISTER } from '../vm/vm'\n\n// const file_path: string = './test/test_files/expression.c';\n// const inputStream = CharStreams.fromString(fs.readFileSync(file_path, 'utf8'));\n// const inputStream = CharStreams.fromString(\"int c = a + b;\");\nconst inputStream = CharStreams.fromString(\"int a = 1 + 2;\");\nconst lexer = new CLexer(inputStream);\nconst tokenStream = new CommonTokenStream(lexer);\nconst parser = new CParser(tokenStream);\nconst tree = parser.compilationUnit()\n// console.log(tree)\nconst get_rule_name = (ctx:any) =>\n    CParser.ruleNames[ctx.ruleIndex]\n\nconst is_rule = (node:any) => \n    get_rule_name(node) !== undefined\n\nconst print_tree = (root : any, depth : number) => {\n    if (!root) return;\n    if (is_rule(root)) {\n        console.log(\"-\".repeat(depth * 2) + get_rule_name(root))\n        const rule = get_rule_name(root)\n    }\n    else\n        console.log(\"-\".repeat(depth * 2) + root.symbol.text)\n    if (root.children)\n        root.children.forEach((c:any) => print_tree(c, depth + 1))\n}\n/**\n * Given a node, will take it and check for rules\n * Due to nesting, we need to check first.\n * i.e. additive => multiplicativeExpression (('+'|'-') multiplicativeExpression)*\n * >=2 children means that there is an expansion\n*/\nconst compile = (root: any) => {\n    // compile_comp[root.tag](root, ce)\n} \n\n// const compile_program = program => {\n//     wc = 0\n//     instrs = []    \n//     compile(program, global_compile_environment)\n//     instrs[wc] = {tag: 'DONE'}\n// }\n\n// const compile_time_environment_position = (env, x) => {\n//     let frame_index = env.length\n//     while (value_index(env[--frame_index], x) === -1) {}\n//     return [frame_index, \n//             value_index(env[frame_index], x)]\n// }\n\n// const value_index = (frame, x) => {\n//   for (let i = 0; i < frame.length; i++) {\n//     if (frame[i] === x) return i\n//   }\n//   return -1;\n// }\n\n\n// wc: write counter\nlet wc: number;\n// instrs: instruction array\nlet instrs;\n// function push_instr(instr : instruction) {\n//     instrs[wc++] = instr;\n// }\n\n\n// const compile_comp = {\n// primaryExpression:\n//     (root: any) => {\n//         // Identifier\n//         // |   Constant\n//         push_instr({operation: OP.PUSH, operands: [imm(BigInt(root.symbol.text))]})\n//         // |   StringLiteral+\n//         // |   '(' expression ')'\n//     },\n// postfixExpression:\n//     (root: any)=> {\n//         // (   primaryExpression\n//         //     // |   '(' typeName ')' '{' initializerList ','? '}'\n//         //)\n//         //('[' expression ']'\n//         //| '(' argumentExpressionList? ')'\n//         //| ('.' | '->') Identifier\n//         //| ('++' | '--')\n//         //)*\n//     },\n// additiveExpression:\n//     (root: any) => {\n//         instrs[wc++] = {operation: OP.POP, operands: [REGISTER.R1]}\n//         instrs[wc++] = {operation: OP.POP, operands: [REGISTER.R2]}\n//         instrs[wc++] = {operation: OP.ADD, operands: [REGISTER.R1, REGISTER.R2]}\n//     },\n// multiplicativeExpression:\n//     (root: any) => {\n//         instrs[wc++] = {operation: OP.POP, operands: [REGISTER.R1]}\n//         instrs[wc++] = {operation: OP.POP, operands: [REGISTER.R2]}\n//         // instrs[wc++] = {operation: OP.MULT, operands: [REGISTER.R1, REGISTER.R2]}\n//     }\n// }\n\n// print_tree(tree, 0)"]}